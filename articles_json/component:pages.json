{"uid": 12287, "pageId": "component:pages", "title": "Pages", "source": "[[iftags +\u0432\u0438\u0437\u0443\u0430\u043b\u044c\u043d\u044b\u0439_\u044d\u043b\u0435\u043c\u0435\u043d\u0442]]\n\n[[include component:croqstyle -=- ]]\n\n[[module CSS]]\ntd { vertical-align: top; }\ntd strong { white-space: nowrap; }\n.options table.wiki-content-table td { border: none; padding: 0.7em 1em; }\n.previews { word-break: none; }\n.previews img, .previews span.img { max-width: 10rem; max-height: 10rem; }\n[[/module]]\n\n[[div style=\"border: 1px solid #ddd; padding: 1em;\"]]\n+ What this is\n\nA component that displays your text on separate pages, for example the pages of a book.\n\nMade by **__user Croquembouche__**.\n\nOther components that simulate pagination:\n\n* [[[component:hf-book-left | Herman Fuller Book Page Left]]]\n* [[[component:hf-book-right | Herman Fuller Book Page Right]]]\n* [[[component:hf-book-right-start | Herman Fuller Book Page Right (Chapter Start)]]]\n* [[[component:hf-start | Herman Fuller GOI: Chapter Start]]]\n* [[[component:hf-left | Herman Fuller GOI: Left Page v2]]]\n* [[[component:hf-right | Herman Fuller GOI: Right Page v2]]]\n\n+ Usage\n\nOn any wiki:\n\n[[div class=\"code terminal\"]]\n**##var(--c-keyword)|[[include##** ##var(--c-symbol)|:component:pages##\n**##var(--c-keyword)||##** **##var(--c-builtin)|medium##****##var(--c-keyword)|=##**##var(--c-symbol)|vintage-book##\n**##var(--c-keyword)||##** **##var(--c-builtin)|contents##****##var(--c-keyword)|=##**\n##var(--c-string)|<h1>Hello, welcome to my book.</h1>\nI hope you <em>really enjoy</em> it so that the pain it took to write it was worth it.##\n**##var(--c-keyword)|]]##**\n[[/div]]\n\nThere are two parameters for this component.\n\n[[div class=\"options\"]]\n|| **medium** || What medium should your text be presented in? This determines the background image of each page, the font, etc. I'm open to adding more options -- please contact me ([[user Croquembouche]]) if you have an idea. _\nThese are documented in detail at the bottom of this page. ||\n|| **contents** || The contents of your pages. Can include very simple formatting and images. ||\n|| **style** || CSS styling to inject into the document. ||\n[[/div]]\n\nThe contents parameter can spread across as many lines as you want.\n\nThe contents may not contain the following characters:\n\n* {{|}} (pipe symbol)\n* {{@@`@@}} (backtick), unless it's preceded by a backslash ({{\\`}})\n* {{]]}} (two closing brackets), but only if it's at the end of a line or followed by whitespace\n\n[[/div]]\n\n _\n\n[[div style=\"border: 1px solid #ddd; padding: 1em;\"]]\n\n+ Text formatting\n\nThe contents parameter won't be rendered by Wikidot. It goes straight through to a custom parser that I've written myself that spits out HTML.\n\nAll that lovely Wikidot syntax that you're used to goes out of the window. Instead, you'll have to write inline HTML.\n\nFor example:\n\n* To make bold text, instead of {{@@**text**@@}}, write {{<b>text</b>}}.\n* To make an em dash, instead of {{@@--@@}}, write a literal em dash ({{\u2014}}).\n* To make a horizontal rule, instead of @@-----@@, write {{<hr>}}.\n\nUnlike HTML, you //do not// need to write {{<p>...</p>}} around each line.\n\n-----\n\n+ Images\n\nInclude images using standard HTML for an image:\n\n[[div class=\"code terminal\"]]\n##var(--c-string)|<img src=\"@@https://scpfoundation.net/local--files/your-articles/your-image.png@@\">##\n[[/div]]\n\nYou can fix the image to the top or bottom of a page by adding either {{position=\"top\"}} or {{position=\"bottom\"}}. This will fix the image to either the top or the bottom of whatever page it would appear on. This only works for images that are on a line by themselves, not in the middle of text:\n\n[[div class=\"code terminal\"]]\n##var(--c-string)|<img position=\"top\" src=\"URL\">##\n[[/div]]\n\nTo horizontally centre an image, add this CSS to its {{style}} attribute directly:\n\n[[div class=\"code terminal\"]]\n##var(--c-string)|<img style=\"####var(--c-builtin)|display##: ##var(--c-value)|block##; ##var(--c-builtin)|margin-left##: ##var(--c-value)|auto##; ##var(--c-builtin)|margin-right##: ##var(--c-value)|auto##;##var(--c-string)|\" src=\"URL\">##\n[[/div]]\n\nIf an image is too tall to fit on a single page, the bottom of it will be chopped off.\n\n-----\n\n+ Page breaks\n\nSometimes you want to say \"okay, stop there. Start the next bit on a new page. The rest of this page can be empty.\"\n\nTo do that, on a line by itself, add a page break:\n\n[[div class=\"code terminal\"]]\n##var(--c-string)|<br class=\"page-break\">##\n[[/div]]\n\nThe thing that comes next after a page break will be on the next page. If there's an image with {{position=\"bottom\"}} just //before// the page break, it will still be at the bottom of that page, as expected.\n\n-----\n\n+ Advanced usage\n\nYou can include CSS via the style parameter, and embedded Javascript in the contents parameter.\n\n++ Using CSS\n\nAny CSS you include in the style parameter will be injected into the pages. Use this to tweak things, add classes that you can use in your content, and change the font (for example).\n\nFor example:\n\n[[div class=\"code terminal\"]]\n**##var(--c-keyword)|[[include##** ##var(--c-symbol)|:component:pages##\n**##var(--c-keyword)||##** **##var(--c-builtin)|medium##****##var(--c-keyword)|=##**##var(--c-symbol)|vintage-book##\n**##var(--c-keyword)||##** **##var(--c-builtin)|style##****##var(--c-keyword)|=##**\n##var(--c-operator)|@import## ##var(--c-builtin)|url##(##var(--c-string)|'@@https://fonts.googleapis.com/css2?family=Architects+Daughter@@'##);\n\n##var(--c-keyword)|.####var(--c-symbol)|page## {\n@@  @@##var(--c-builtin)|font-family##: ##var(--c-string)|'Architects Daughter'##, ##var(--c-value)|cursive##;\n@@  @@##var(--c-builtin)|margin##: ##var(--c-value)|2rem##;\n}\n\n##var(--c-keyword)|.####var(--c-symbol)|page## ##var(--c-keyword)|.####var(--c-symbol)|red## {\n@@  @@##var(--c-builtin)|color##: ##var(--c-value)|red##;\n}\n**##var(--c-keyword)||##** **##var(--c-builtin)|contents##****##var(--c-keyword)|=##**\n##var(--c-string)|This text will appear <span class=\"red\">handwritten</span>.##\n**##var(--c-keyword)|]]##**\n[[/div]]\n\nYou can't style this component with a CSS module elsewhere on your article -- this is the only way.\n\n**Tip!** You can add parameters in any order you like, but it's a good idea to put the style parameter //above// the contents parameters. Your contents parameter will probably be really, really long -- you might find it easier to have all the settings and CSS at the top.\n\n++ Using Javascript\n\nThe contents parameter will be parsed as a Javascript [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals template literal], which is why it can't contain a backtick.\n\nBecause of that, you can include arbitrary Javascript in the contents parameter inside an embedded expression ({{${expression}}}), which will be executed and substituted back into the string. For example:\n\n[[div class=\"code terminal\"]]\n**##var(--c-keyword)|[[include##** ##var(--c-symbol)|:scp-wiki:component:pages##\n**##var(--c-keyword)||##** **##var(--c-builtin)|medium##****##var(--c-keyword)|=##**##var(--c-symbol)|vintage-book##\n**##var(--c-keyword)||##** **##var(--c-builtin)|contents##****##var(--c-keyword)|=##**\n##var(--c-string)|The day today is## ##var(--c-operator)|${####var(--c-keyword)|new## ##var(--c-builtin)|Date##().##var(--c-builtin)|toLocaleString##(##var(--c-string)|\"default\"##, { ##var(--c-symbol)|weekday##: ##var(--c-string)|\"long\"## })##var(--c-operator)|}####var(--c-string)|.##\n**##var(--c-keyword)|]]##**\n[[/div]]\n\nThis book will tell the reader the name of the current day.\n\nShould you do this? Probably not. But you //can//.\n\nPlease note that while you can include arbitrary Javascript, the OR operator ({{||}}) is unavailable because it's made of pipe symbols, which are forbidden. However, using AND and NOT, you can [https://stackoverflow.com/questions/8374895/how-to-make-logical-or-with-and-and-not create an OR yourself]: NOT((NOT x) AND (NOT y)) is equivalent to (x OR y). In Javascript, that's {{!((!x) && (!y))}}.\n\n[[/div]]\n\n  _\n\n[[div style=\"border: 1px solid #ddd; padding: 1em;\"]]\n\n+ Medium Options\n\nThe following are your options for the '{{medium}}' parameter.\n\nI am actively soliciting requests for new medium options. I mean, the title of this component is //'Papers, Pages and Post-it Notes'//, it's designed to be as versatile as possible, but right now, it can only do a couple of things.\n\nIf you have any requests for paginated formats, please let me know ([[user Croquembouche]]).\n\nEach medium has a fixed aspect ratio that determines its height for any browser width.\n\n[[div class=\"previews\"]]\n||~ Medium ||~ Background ||~ Font ||~ y:x ||~ Source ||\n|| {{plain}} //(default)// || [[image plain-preview.png]] || //Browser default// || 4:7 || ||\n|| {{vintage-book}} || [[image book.300px.png]] || Libre Baskerville || 10:9 || [https://commons.wikimedia.org/wiki/File:Powiedz_ty_muzyko_moia.jpg Public Domain] ||\n|| {{gdocs}} || [[span class=\"img\" style=\"display: block; height: 100%; aspect-ratio: 0.7; border: thin solid grey; background: white;\"]]@@ @@[[/span]] || sans-serif || sqrt(2):1 || ||\n[[/div]]\n\n[[/div]]\n\n _\n\n[[div style=\"border: 1px solid #ddd; padding: 1em;\"]]\n\n+ Source code\n\n[[collapsible show=\"+ Show source code\"]]\n\n++ HTML\n\nCheck the bottom of the page source for the {{@@[[html]]@@}} module.\n\n++ CSS\n\n[[code type=\"css\"]]\n/* Imports */\n/* Note that fonts MUST be imported synchronously using the link element,\n * otherwise the page structure may not render properly */\n\n/* Styling */\n\n.pages-container {\n  font-size: min(4vw, 1rem);\n  position: relative;\n}\n\n/* A page without a medium needs some default styling. */\n.aspect-ratio {\n  margin: 1rem 0;\n  /* The padding-top should be the ratio of the bg image's width / height */\n  padding-top: calc(400 / 700 * 100%);\n  position: relative;\n}\n.page {\n  height: 0;\n  padding: 2rem 2rem 3rem;\n  position: absolute;\n  height: 100%; width: 100%; top: 0; left: 0;\n  box-sizing: border-box;\n}\n.page::before {\n  content: \"\";\n  position: absolute;\n  height: 100%; width: 100%; top: 0; left: 0;\n  pointer-events: none;\n  background-image: linear-gradient(beige, antiquewhite);\n  background-size: 100% 100%;\n  background-repeat: no-repeat;\n  z-index: -1;\n  box-sizing: border-box;\n}\n\n.content {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n}\n.content > * {\n  margin-block-start: 0.5em;\n  margin-block-end: 0.5em;\n}\n\np, img, div { max-width: 100%; }\nh1, h2, h3, h4, h5, h6 { line-height: 1em; }\n  \n\n/* Each medium gets its own style. */\n\n/* Vintage book */\n\n.vintage-book {\n  font-family: 'Libre Baskerville', serif;\n  color: #514132;\n  line-height: 1.5em;\n  text-align: justify;\n}\n.vintage-book .aspect-ratio {\n  padding-top: calc(2500 / 2250 * 100%);\n}\n.vintage-book .page {\n  padding: 8vw 17vw;\n}\n.vintage-book .page::before {\n  background-image:\n    url(https://scpfoundation.net/local--files/component:pages/book.1000px.webp);\n}\n.vintage-book > :nth-child(2n+1) .page::before {\n  transform: scaleX(-1);\n}\n.vintage-book .content {\n  transform: skewY(-0.5deg);\n}\n.vintage-book > :nth-child(2n+1) .content {\n  transform: skewY(0.5deg);\n}\n.vintage-book .split-paragraph-start {\n  text-align-last: justify;\n}\n.vintage-book .content > p:not(.split-paragraph-end):not(.is-image) {\n  text-indent: 2em;\n}\n\n/* Gdocs */\n\n.gdocs {\n  font-family: sans-serif;\n  color: #15141A;\n  line-height: 1.25em;\n}\n.gdocs .aspect-ratio {\n  padding-top: calc(1.414 / 1 * 100%);\n}\n.gdocs .page {\n  padding: 10vw 10vw;\n}\n.gdocs .page::before {\n  background: white;\n  border: thin solid grey;\n}\n[[/code]]\n\n++ Javascript\n\n[[code type=\"javascript\"]]\nlet pageCount = 1\nlet resetCount = 0\n\n// contents is already defined, see [[html]]\n\n// Replace line breaks with <p>\ncontents = contents\n  .split(\"\\n\")\n  .filter(line => line.length > 0)\n  .map(line => {\n    return $(`<p>${line}<${\"/p\"}>`) // to fix Wikidot's syntax highlighting\n  })\n\n// Convert contents from text to jQuery objects\ncontents = $($.map(contents, el => el.get()))\n\n// Remove empty objects\ncontents = contents.filter(\":not(:empty)\")\n\n// Add flex order to paragraphs containing positioned images\ncontents.map((index, element) => {\n  element = $(element)\n  if (\n    element.is(\"p\") &&\n    element.text().length === 0 &&\n    element.children().length === 1 &&\n    element.children().first().is(\"img\")\n  ) {\n    // Mark images\n    element.addClass(\"is-image\")\n    if (\n      [\"top\", \"bottom\"].includes(element.children().first().attr(\"position\"))\n    ) {\n      // Order positioned images\n      element.css(\n        \"order\",\n        { top: -1, bottom: 1 }[element.children().first().attr(\"position\")]\n      )\n    }\n  }\n})\n\n// Once everything is ready, render the pages\n// This includes image loading, so this is window load instead of document ready\n$(window).on(\"load\", () => {\n  resetCount = 0\n  let thisDocument = $(\".pages-container\")\n  resetPage(thisDocument)\n  // Sometimes doesn't work after first load - try again\n  setTimeout(() => resetPage(thisDocument), 2000)\n\n  let windowWidth = $(window).width()\n\n  // Rerender the pages when the window size is changed\n  $(window).on(\n    \"resize\",\n    debounce(() => {\n      if ($(window).width() !== windowWidth) {\n        windowWidth = $(window).width()\n        resetPage(thisDocument)\n      }\n    }, 200)\n  )\n})\n\n/**\n * Debounces the execution of a function - it will only fire once its\n * triggering events have stopped.\n *\n * By David Walsh: https://davidwalsh.name/javascript-debounce-function (MIT)\n *\n * @param func - The function to debounce.\n * @param wait - Milliseconds after which to assume there'll be no more events.\n */\nfunction debounce(func, wait) {\n  let timeout\n  return function executedFunction(...args) {\n    const later = () => {\n      clearTimeout(timeout)\n      func(...args)\n    }\n    clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n  }\n}\n\nfunction resetPage(thisDocument) {\n  thisDocument.empty()\n  pageCount = 1\n  thisPage = preparePage(thisDocument)\n  setTimeout(() => {\n    makePage(contents.clone(), thisPage, thisDocument)\n    checkPage(thisDocument)\n  }, 1)\n}\n\nfunction preparePage(thisDocument) {\n  const aspectBox = $(`<div class='aspect-ratio'></div>`).appendTo(thisDocument)\n  return $(`<div class='page'></div>`).appendTo(aspectBox)\n}\n\n/**\n * Recursively creates pages and sorts text into them.\n *\n * @param contents - Array of (remaining) HTML paragraphs.\n * @param thisPage - The current page as a jQuery element.\n */\nfunction makePage(contents, thisPage, thisDocument) {\n  console.log(`Making page ${pageCount++}`)\n\n  let nextPageContents = []\n\n  // Add the contents to the page\n  thisPageContents = $(\"<div class='content'></div>\").appendTo(thisPage)\n  thisPageContents.empty().append(contents)\n\n  // The page height is the maximum height of page content\n  const pageHeight = thisPage.height()\n\n  // The content height is the actual height of page content\n  const contentHeight = thisPageContents.outerHeight()\n\n  // If the content exceeds the page, create a new one\n  if (\n    contentHeight > pageHeight ||\n    thisPageContents.has(\"br.page-break\").length > 0\n  ) {\n    console.log(`Split needed (${contentHeight} > ${pageHeight})`)\n\n    // Find the first element that can't fully appear on the page\n    // (or a page break)\n    const children = thisPageContents.children()\n    let lastParagraphIndex = -1\n    for (let index = 0; index < children.length; index++) {\n      const child = $(children.eq(index))\n      // First, check for a page break\n      if (child.has(\"br.page-break\").length > 0) {\n        console.log(\"Splitting on page break\")\n        lastParagraphIndex = index\n        break\n      }\n      // Second, check for an element that doesn't fit\n      // Do this by summing the height of all children up to and this one,\n      // then compare that to the desired page height\n      const childBottom =\n        children\n          .slice(0, index)\n          .toArray()\n          .reduce((height, child) => {\n            return height + $(child).outerHeight(true)\n          }, 0) + child.outerHeight(true)\n      console.log(index, childBottom, thisPage.height())\n      if (childBottom > thisPage.height()) {\n        lastParagraphIndex = index\n        break\n      }\n    }\n\n    if (lastParagraphIndex === -1) {\n      // No elements can fit on this page!\n      // Genuinely unsure what to do here\n      // The default action is \"move everything\" so that's probably... fine...\n      console.log(\"No elements can fit on this page\")\n    } else {\n      // There's an element that either can't be on the page, or partially can\n      console.log(`Splitting element with index ${lastParagraphIndex}`)\n\n      // Trim away the content that we already know will fit\n      nextPageContents = contents.splice(lastParagraphIndex)\n      // The partial element is the first of nextPageContents.\n\n      // Set the html to the contents we know will fit\n      thisPageContents.empty().append(contents)\n\n      // Extract a copy of the partial element from the next page\n      let partialElement = $(nextPageContents[0]).clone()\n\n      // If the partial element is p, it can be split up\n      if (partialElement.is(\"p\") && partialElement.text() != \"\") {\n        // The element can be split across pages - move some of it back\n\n        partialElement.appendTo(thisPageContents)\n\n        const partialText = partialElement.text()\n        let keepWords = partialText.split(\" \")\n        let moveWords = []\n\n        // Remove words one by one until the element fits\n        for (let index = keepWords.length; index > 0; index--) {\n          if (thisPageContents.outerHeight(true) <= thisPage.height()) {\n            // It fits! Declare split\n            console.log(\n              `Split successful after ${moveWords.length} words removed`\n            )\n            if (moveWords.length > 0) {\n              partialElement.addClass(\"split-paragraph-start\")\n            }\n            break\n          }\n          let word = keepWords.pop()\n          moveWords.unshift(word)\n          partialElement.text(keepWords.join(\" \"))\n        }\n\n        // Check if this was successful - might have just run out of words\n        if (keepWords.length === 0) {\n          // Not successful - undo everything\n          console.log(\"Split unsuccessful; partial element removed\")\n          partialElement.remove()\n        } else {\n          // Success! Update the next page with the retained words\n          nextPageContents[0].textContent = moveWords.join(\" \")\n        }\n      } else {\n        // The element can't be split, so don't move anything back\n        // If it's the first element, it probably came from the previous page\n        // If that's the case, jut dump it here\n        if (lastParagraphIndex == 0) {\n          console.log(\"Something couldn't be split, so it was dumped\")\n          partialElement.appendTo(thisPageContents)\n          partialElement.css(\"height\", pageHeight)\n          partialElement.css(\"overflow\", \"hidden\")\n          nextPageContents.shift()\n        }\n      }\n    }\n\n    // If the last element of this page was split, so it the first of the next\n    if (\n      thisPageContents.children().last().is(\"p.split-paragraph-start\") &&\n      $(nextPageContents[0]).is(\"p\")\n    ) {\n      nextPageContents[0].classList.add(\"split-paragraph-end\")\n    }\n\n    // If the very first element of the next page is a page break, chuck it out\n    if ($(nextPageContents[0]).has(\"br.page-break\").length > 0) {\n      console.log(\"Scrapping a page break\")\n      nextPageContents.shift()\n    }\n\n    // Slap an arbitrary limit on the recursion\n    if (pageCount < 1000) {\n      // Create a new page\n      const nextPage = preparePage(thisDocument)\n      makePage(nextPageContents, nextPage, thisDocument)\n    } else {\n      console.log(\"Pages stopped after 1000\")\n    }\n  } else {\n    console.log(\"No split needed\")\n  }\n}\n\nfunction checkPage(thisDocument) {\n  if (resetCount > 5) {\n    console.log(\"Overflow reset limit reached\")\n    return\n  }\n  let shouldReset = 0\n  thisDocument.children().each((index, aspectBox) => {\n    aspectBox = $(aspectBox)\n    pageBox = $(aspectBox.children().first())\n    contentBox = $(pageBox.children().first())\n    if (contentBox.outerHeight(true) > pageBox.height()) {\n      shouldReset++\n    }\n    if (shouldReset > 1) {\n      console.log(`${shouldReset} pages overflowing, resetting`)\n      resetCount++\n      resetPage(thisDocument)\n      checkPage(thisDocument)\n    } else {\n      console.log(\"No overflow reset needed\")\n    }\n  })\n}\n[[/code]]\n\n[[/collapsible]]\n\n[[/div]]\n\n[[/iftags]]\n\n[[html]]\n<base target=\"_top\"></base>\n\n<link href=\"https://fonts.googleapis.com/css2?family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&display=swap\" rel=\"stylesheet\">\n\n<link href=\"https://files.scpfoundation.net/local--files/component:pages/code_1.css\" rel=\"stylesheet\">\n\n<style>\n  /* The user's CSS should override any existing CSS. */\n  {$style}\n</style>\n\n<body>\n  <div class=\"pages-container {$medium}\"></div>\n</body>\n\n<script src=\"https://code.jquery.com/jquery-3.5.1.slim.min.js\"></script>\n<script>\n  // Recieve book contents from include parameter\n  let contents = `{$contents}`\n</script>\n<script src=\"https://files.scpfoundation.net/local--files/component:pages/code_2.js\"></script>\n[[/html]] ", "tags": ["\u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430:\u0432\u0438\u0437\u0443\u0430\u043b\u044c\u043d\u044b\u0439_\u044d\u043b\u0435\u043c\u0435\u043d\u0442"], "parent": null, "locked": false}